#!/usr/bin/env php
<?php

use JetBrains\PhpStorm\NoReturn;

include('helpers.php');

class Init
{
    use Helpers;

    private string $testName;
    private string $engineName;
    private string $type;
    private string $suffix;
    private string $measuresLogPath;


    public function __construct(
        string $testName,
        string $engineName,
        string $type
    ) {
        $this->testName = $testName;
        $this->engineName = $engineName;
        $this->type = $type;

        $this->getSuffix();
        $this->measuresLogPath = "/tmp/inflate_$this->engineName.txt";

        $this->preHook()
        && $this->inflateHook()
        && $this->postHook();
    }

    private function getSuffix(): void
    {
        $this->suffix = ($this->type === "")
            ? ""
            : "_$this->type";
    }

    public function preHook(): bool
    {
        return $this->processHook("pre_hook", "Pre hook");
    }

    public function inflateHook(): bool
    {
        $scriptPath = "suffix=$this->suffix $this->engineName/inflate";

        $pid = pcntl_fork();
        if ($pid == -1) {
            die('Could not fork process');
        } else {
            if ($pid) {
                $startTime = microtime(true);
                $exitCode = $this->runScript($scriptPath);

                posix_kill($pid, SIGTERM);

                pcntl_wait($status);

                if ($exitCode === 0) {
                    $this->saveStats($startTime);
                    return true;
                }

                throw new RuntimeException("Inflate hook unexpected exit");
            } else {
                $this->measureStats();
            }
        }
    }

    public function postHook(): bool
    {
        return $this->processHook("post_hook", "Post hook");
    }

    private function runScript($scriptPath): ?int
    {
        $descriptors = [
            0 => ["pipe", "r"],  // stdin
            1 => ["pipe", "w"],  // stdout
            2 => ["pipe", "w"]   // stderr
        ];

        $process = proc_open($scriptPath, $descriptors, $pipes);
        $exitCode = null;

        if (is_resource($process)) {
            while ($line = fgets($pipes[1])) {
                echo $line;
            }

            fclose($pipes[1]);
            fclose($pipes[2]);
            $exitCode = proc_close($process);
        }

        return $exitCode;
    }

    #[NoReturn]
    private function measureStats(): void
    {
        declare(ticks=1);

        pcntl_signal(SIGTERM, function () {
            exit(0);
        });

        if (file_exists($this->measuresLogPath)) {
            unlink($this->measuresLogPath);
        }
        if (!$fp = fopen($this->measuresLogPath, 'w')) {
            echo "Cannot open file ($this->measuresLogPath)";
            exit(1);
        }

        while (true) {
            $dockerStats
                = shell_exec("docker stats --no-stream | grep $this->engineName");

            if (fwrite($fp, "$dockerStats") === false) {
                echo "Cannot write to file ($this->measuresLogPath)";
                exit(1);
            }
            sleep(1);
        }
    }


    public function calculateStats(): array
    {
        $cpu = [];
        $ram = [];
        $disc = [];

        $content = file_get_contents($this->measuresLogPath);
        //CONTAINER ID   NAME                   CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O        PIDS
        $content = explode("\n", $content);

        foreach ($content as $row) {
            if ($row === '') {
                continue;
            }

            $parts = array_values(array_filter(explode(' ', $row), 'strlen'));

            $cpu[] = (float) $parts[2];
            $ram[] = (float) $parts[3];
            $disc[] = (float) $parts[10] + (float) $parts[12];
        }

        unset($content);

        $results = [];
        foreach (['cpu', 'ram', 'disc'] as $measureType) {
            $results[$measureType]['average']
                = round($this->calculateAverage($$measureType), 4);

            sort($$measureType);

            $results[$measureType]['median']
                = round($this->calculateMedian($$measureType), 4);

            $results[$measureType]['95p']
                = round($this->calculate95Percentile($$measureType), 4);
        }

        $results['cpu']['average'] = round($results['cpu']['average'] / 100, 4);
        $results['cpu']['median'] = round($results['cpu']['median'] / 100, 4);
        $results['cpu']['95p'] = round($results['cpu']['95p'] / 100, 4);

        return $results;
    }

    private function saveStats(float $startTime): void
    {
        $elapsed = microtime(true) - $startTime;

        $date = date('ymd_his');
        $folderPath = "../../results/$this->testName/$this->engineName/$date/";
        $fileName = $this->testName."_".$this->engineName."__init";

        if (!file_exists($folderPath)) {
            mkdir($folderPath);
        }

        file_put_contents(
            $folderPath.$fileName,
            serialize([
                'elapsed_time' => $elapsed,
                'metrics' => $this->calculateStats(),
                'engine' => $this->engineName,
                'test' => $this->testName,
                'type' => $this->type
            ]));

        unlink($this->measuresLogPath);
    }


    private function calculateAverage(array $values): float|int
    {
        return array_sum($values) / count($values);
    }

    private function calculateMedian(array $sortedValues): float|int
    {
        $middleKey = (int) (sizeof($sortedValues) / 2);

        $lowerBound = $sortedValues[$middleKey - 1];
        $higherBound = $sortedValues[$middleKey + 1];

        return ($lowerBound + $higherBound) / 2;
    }

    private function calculate95Percentile(array $sortedValues): float|int
    {
        $p95key = (int) (sizeof($sortedValues) * 0.95);
        return $sortedValues[$p95key];
    }


    private function processHook(string $command, string $hookName): bool
    {
        $hookPath
            = "test=$this->testName suffix=$this->suffix $this->engineName/"
            .$command;
        $exitCode = $this->runScript($hookPath);
        if ($exitCode === 10) {
            // If we don't need to rebuild this engine
            // pre_hook should return us exit code 10
            return false;
        } elseif ($exitCode === 0) {
            return true;
        }

        throw new RuntimeException("$hookName unexpected exit");
    }
}

$arguments = Init::getopt([
    "test:",
    "engine:",
    "type:"
]);

foreach (['engine', 'test'] as $argument) {
    if (!isset($arguments[$argument])) {
        Init::die("Argument $argument is mandatory", 1);
    }
}


new Init($arguments['test'], $arguments['engine'], $arguments['type'] ?? "");
